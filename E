Para implementar a funcionalidade de exibir a tela de configuração do perfil na primeira vez que o usuário faz login e, em logins subsequentes, redirecioná-lo para a visão geral, precisamos seguir esses passos:

1. **Adicionar um campo no modelo do usuário para verificar se o perfil foi configurado.**
2. **Modificar o fluxo de login para redirecionar para a configuração do perfil, se necessário.**
3. **Modificar as views para exibir o formulário de configuração do perfil.**

### Passo 1: Adicionar um campo no modelo do usuário

Primeiro, adicione um campo ao modelo do usuário que indicará se o perfil foi configurado:

```bash
rails generate migration AddProfileConfiguredToUsers profile_configured:boolean
rails db:migrate
```

### Passo 2: Modificar o fluxo de login

No controlador de sessões (`app/controllers/sessions_controller.rb`), modifique a ação de criação (`create`) para redirecionar para a configuração do perfil se o usuário estiver fazendo login pela primeira vez.

```ruby
class SessionsController < ApplicationController
  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      session[:user_id] = user.id
      if user.profile_configured
        redirect_to dashboard_path, notice: "Entrada com sucesso!"
      else
        redirect_to dashboard_perfil_path, notice: "Complete seu perfil."
      end
    else
      flash.now[:alert] = "Combinação de email/senha inválida."
      render :new
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_path, notice: "Saiu com sucesso!"
  end
end
```

### Passo 3: Modificar as views

**Perfil**

No arquivo `app/views/dashboard/perfil.html.erb`, adicione um formulário para editar o perfil. Modifique a action para salvar as alterações e definir o perfil como configurado.

```erb
<div class="container mt-4">
  <h2>Dados do Perfil</h2>
  <%= form_with(model: current_user, url: dashboard_perfil_path, method: :patch, local: true) do |form| %>
    <div class="row">
      <div class="col-md-4 text-center">
        <div class="profile-pic">
          <img src="default-avatar.png" alt="Foto do Perfil">
          <%= form.file_field :avatar, class: "form-control-file mt-2" %>
        </div>
      </div>
      <div class="col-md-8">
        <div class="form-group">
          <%= form.label :nome, "Nome do Encarregado:" %>
          <%= form.text_field :nome, class: "form-control" %>
        </div>
        <div class="form-group">
          <%= form.label :data_nascimento, "Data de Nascimento:" %>
          <%= form.date_field :data_nascimento, class: "form-control" %>
        </div>
        <div class="form-group">
          <%= form.label :endereco, "Endereço Residencial:" %>
          <%= form.text_field :endereco, class: "form-control" %>
        </div>
        <div class="form-group">
          <%= form.label :telefone, "Telefone:" %>
          <%= form.text_field :telefone, class: "form-control" %>
        </div>
        <div class="form-group">
          <%= form.label :email, "E-mail:" %>
          <%= form.email_field :email, class: "form-control", readonly: true %>
        </div>
        <div class="form-group">
          <%= form.label :genero, "Gênero:" %>
          <%= form.select :genero, ["Feminino", "Masculino"], { include_blank: true }, class: "form-control" %>
        </div>
        <div class="form-group">
          <%= form.label :nacionalidade, "Nacionalidade:" %>
          <%= form.text_field :nacionalidade, class: "form-control" %>
        </div>
        <%= form.submit "Salvar", class: "btn btn-success" %>
      </div>
    </div>
  <% end %>
</div>
```

### Atualização do Controlador de Dashboard

No controlador `DashboardController`, adicione uma ação para atualizar o perfil:

```ruby
class DashboardController < ApplicationController
  before_action :require_login

  def index
  end

  def perfil
    @user = current_user
  end

  def conta_bancaria
  end

  def seguranca
  end

  def update_perfil
    @user = current_user
    if @user.update(user_params)
      @user.update(profile_configured: true)
      redirect_to dashboard_path, notice: "Perfil atualizado com sucesso!"
    else
      render :perfil
    end
  end

  private

  def require_login
    unless logged_in?
      redirect_to login_path, alert: "Você precisa estar logado para acessar essa página."
    end
  end

  def user_params
    params.require(:user).permit(:nome, :data_nascimento, :endereco, :telefone, :email, :genero, :nacionalidade, :avatar)
  end
end
```

**Rotas**

Adicione a rota para atualizar o perfil no `config/routes.rb`:

```ruby
Rails.application.routes.draw do
  root "main#index"
  
  get 'signup', to: 'users#new'
  post 'signup', to: 'users#create'
  get 'login', to: 'sessions#new'
  post 'login', to: 'sessions#create'
  delete 'logout', to: 'sessions#destroy'

  get 'dashboard', to: 'dashboard#index'
  get 'dashboard/perfil', to: 'dashboard#perfil'
  patch 'dashboard/perfil', to: 'dashboard#update_perfil'
  get 'dashboard/conta_bancaria', to: 'dashboard#conta_bancaria'
  get 'dashboard/seguranca', to: 'dashboard#seguranca'

  resources :users, except: [:index, :show]
end
```

### Passo 4: Estilização das Páginas

Adicione ou modifique o CSS para centralizar o formulário e ajustar a aparência:

```css
body {
  background-color: #b3e5fc; /* Azul bebê */
}

.container {
  max-width: 600px;
  margin: auto;
  padding-top: 50px;
}

.profile-pic {
  text-align: center;
  margin-bottom: 20px;
}

.profile-pic img {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  display: block;
  margin: auto;
}

.payment-icon {
  width: 50px;
  margin: 10px;
}
```
Para criar uma interface de bate-papo similar à mostrada na imagem, você precisará implementar tanto o design front-end quanto a lógica back-end para gerenciar as mensagens entre os usuários. Vamos dividir isso em várias etapas:

1. **Configuração do Banco de Dados**
2. **Controladores e Rotas**
3. **Views e Estilo**
4. **WebSocket para atualização em tempo real (opcional, mas recomendado)**

### 1. Configuração do Banco de Dados

Primeiro, crie os modelos necessários para armazenar as mensagens e as conversas.

```bash
rails generate model Conversation user1_id:integer user2_id:integer
rails generate model Message conversation_id:integer user_id:integer content:text
rails db:migrate
```

### 2. Controladores e Rotas

**Conversas**

Crie um controlador para gerenciar as conversas:

```bash
rails generate controller Conversations
```

No `app/controllers/conversations_controller.rb`:

```ruby
class ConversationsController < ApplicationController
  before_action :require_login

  def index
    @conversations = Conversation.where("user1_id = ? OR user2_id = ?", current_user.id, current_user.id)
  end

  def show
    @conversation = Conversation.find(params[:id])
    @messages = @conversation.messages
  end

  def create
    if Conversation.between(params[:user1_id], params[:user2_id]).present?
      @conversation = Conversation.between(params[:user1_id], params[:user2_id]).first
    else
      @conversation = Conversation.create!(conversation_params)
    end

    redirect_to conversation_path(@conversation)
  end

  private

  def conversation_params
    params.permit(:user1_id, :user2_id)
  end
end
```

Adicione o método `between` ao modelo `Conversation`:

```ruby
class Conversation < ApplicationRecord
  has_many :messages, dependent: :destroy

  scope :between, -> (user1_id, user2_id) {
    where("(conversations.user1_id = ? AND conversations.user2_id = ?) OR (conversations.user1_id = ? AND conversations.user2_id = ?)", user1_id, user2_id, user2_id, user1_id)
  }
end
```

**Mensagens**

Crie um controlador para gerenciar as mensagens:

```bash
rails generate controller Messages
```

No `app/controllers/messages_controller.rb`:

```ruby
class MessagesController < ApplicationController
  before_action :require_login

  def create
    @message = current_user.messages.build(message_params)
    @conversation = @message.conversation
    if @message.save
      # Atualizar a lista de mensagens em tempo real, se estiver usando ActionCable
      # ActionCable.server.broadcast 'messages',
      #   message: @message.content,
      #   user: @message.user.email
      redirect_to conversation_path(@conversation)
    else
      redirect_to conversation_path(@conversation), alert: "Não foi possível enviar a mensagem."
    end
  end

  private

  def message_params
    params.require(:message).permit(:content, :conversation_id)
  end
end
```

Adicione associações ao modelo `User`:

```ruby
class User < ApplicationRecord
  has_many :conversations, foreign_key: :user1_id
  has_many :conversations, foreign_key: :user2_id
  has_many :messages
end
```

### 3. Views e Estilo

**Conversations**

No `app/views/conversations/index.html.erb`:

```erb
<div class="container">
  <h2>Conversas</h2>
  <ul>
    <% @conversations.each do |conversation| %>
      <li>
        <%= link_to "Conversar com #{conversation.user2.email}", conversation_path(conversation) %>
      </li>
    <% end %>
  </ul>
</div>
```

No `app/views/conversations/show.html.erb`:

```erb
<div class="container">
  <h2>Bate-Papo</h2>
  <div class="chat-window">
    <div class="messages">
      <% @messages.each do |message| %>
        <div class="message">
          <strong><%= message.user.email %>:</strong> <%= message.content %>
        </div>
      <% end %>
    </div>
    <%= form_with(model: [@conversation, @conversation.messages.build], local: true) do |form| %>
      <div class="input-group">
        <%= form.text_area :content, class: "form-control", rows: 1 %>
        <div class="input-group-append">
          <%= form.submit "Enviar", class: "btn btn-primary" %>
        </div>
      </div>
    <% end %>
  </div>
</div>
```

Adicione o CSS para estilizar a janela de chat:

No `app/assets/stylesheets/application.css` ou `application.scss`:

```css
.container {
  max-width: 800px;
  margin: auto;
}

.chat-window {
  border: 1px solid #ccc;
  padding: 10px;
  background-color: #f9f9f9;
}

.messages {
  height: 400px;
  overflow-y: scroll;
}

.message {
  margin-bottom: 10px;
}

.input-group {
  margin-top: 10px;
}
```

**Rotas**

Adicione as rotas para conversas e mensagens no `config/routes.rb`:

```ruby
Rails.application.routes.draw do
  root "main#index"

  get 'signup', to: 'users#new'
  post 'signup', to: 'users#create'
  get 'login', to: 'sessions#new'
  post 'login', to: 'sessions#create'
  delete 'logout', to: 'sessions#destroy'

  resources :users, except: [:index, :show]
  
  resources :conversations, only: [:index, :show, :create] do
    resources :messages, only: [:create]
  end

  get 'dashboard', to: 'dashboard#index'
  get 'dashboard/perfil', to: 'dashboard#perfil'
  patch 'dashboard/perfil', to: 'dashboard#update_perfil'
  get 'dashboard/conta_bancaria', to: 'dashboard#conta_bancaria'
  get 'dashboard/seguranca', to: 'dashboard#seguranca'
end
```

### 4. WebSocket para atualização em tempo real (opcional, mas recomendado)

Para que a lista de mensagens seja atualizada em tempo real sem a necessidade de recarregar a página, você pode usar o ActionCable do Rails. Aqui está um esboço básico de como fazer isso:

- **Configure ActionCable**: Siga a documentação oficial de [ActionCable](https://guides.rubyonrails.org/action_cable_overview.html) para configurar o WebSocket.
- **Canal de Mensagens**: Crie um canal para transmitir mensagens em tempo real.
- **Atualização de View**: Use JavaScript para atualizar a lista de mensagens quando uma nova mensagem for recebida.

---

Essa é uma implementação básica de um sistema de bate-papo. Certifique-se de testar todas as funcionalidades e ajustar conforme necessário. Para melhorar a experiência do usuário, considere implementar validações, tratamentos de erros e otimizações de desempenho.






seja redirecionado para a visão geral. Os formulários estão configurados para permitir a edição de perfil, dados bancários e segurança, com a estilização básica conforme solicitado. Certifique-se de testar todas as funcionalidades e ajustar conforme necessário.
